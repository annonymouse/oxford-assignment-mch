{- MCH assignment 2014, Part1, "Magic" Squares model
-}
-- Helper functions
-- Definition of the 1 + 2 + 3 ... + n can be simplified to
-- n(n+1) / 2, but I like comprehensions
sumOneToN(0) = 0
sumOneToN(n) = n + sumOneToN(n-1)

-- Sum all elements in a list
n = 4
nsum = sumOneToN(n*n)
groupSum = nsum / n

{-
Each poisition can only be used once, and each number can only be used once.
From here, each row/column/diag can do any move unconstrained as when parrallel
combined they will be limited by the Box and Number processes.
-}

channel place:positions.nums
channel done

positions = {(i,j) | i <- {1..n},j<-{1..n}}
DiagAlpha = { place.(i,j).ns | ns <- {1..n*n}, i <- {1..n}, j <- {1..n}, i == j or i + j == n+1 }
nums = {1..n*n}

-- A box is a position in the magic square, containing some value
-- TODO is this neccesary?
Box(pos) = place!pos?num -> STOP -- Box(pos)

-- The number process constrains the numbers being used only once.
Number({}) = done -> STOP
Number(moves) = place?pos?num:moves -> Number(diff(moves, {num}))

assert STOP [T= Number({1..n*n}) \ {|place|}

-- Row's are indexed top to bottom, if it ever matters, their only state is the
-- current total.  The current total limits the moves possible.

max(total)=
    if groupSum - total > n*n then
        n*n
    else
        groupSum - total

-- {1..0} == {} so not neccesary to have cap
Group(boxes, total)
     = place?pos:boxes?num:{1..max(total)} -> Group(boxes, total+num)

Row(y) = Group({(i, y) | i <- {1..n}}, 0)

Col(x) = Group({(x, j) | j <- {1..n}}, 0)

DiagAsc() = Group({(i, j) | i <- {1..n}, j <- {1..n}, i == j}, 0)
DiagDes() = Group({(i, j) | i <- {1..n}, j <- {1..n}, i + j == n+1}, 0)

--Puzzle1 = (Row(1) [|{|place|}|] Col(1)) [|{|place|}|] ((DiagAsc() [|{|place|}|] DiagDes) [|{|place|}|] Box(1,1))

Rows = ||| i:{1..n} @ Row(i)
Cols = ||| i:{1..n} @ Col(i)
-- Diagnoals have to do the middle together if n is an odd number
-- FIXME 2,2, is hardcoded, not every Diag has a middle.
Diags = DiagAsc() [|{|place.(2,2)|}|] DiagDes()
Boxes = [|{done}|] pos:positions @ Box(pos)
BoxesAndNumbers = Number({1..n*n}) [|{|place|}|] Boxes

-- Only work toghether on diagonal moves.
Puzzle = ((Rows [|{|place|}|] Cols) [|DiagAlpha|] Diags ) [|{|place|}|] BoxesAndNumbers

-- done is not hidden, so the trace refinement should should the steps required to complete puzzle

assert STOP [T= Puzzle \ {|place|}

assert STOP [T= BoxesAndNumbers \ {|place|}

assert STOP [T= BoxesAndNumbers [|{|place|}|] Cols \ {|place|}

{-
-- Col's are indexed from left to right (although I suppose it doesn't matter)
--Cols(c) =o 

-}

channel anEvent

Test = anEvent -> done -> STOP [|{|anEvent|}|] anEvent -> STOP
Test2 = anEvent -> STOP [|{|anEvent|}|] Test


-- Diag's are done separately as ascending / and descending \
