{- MCH assignment 2014, Part1, "Magic" Squares model
-}
-- Helper functions
-- Definition of the 1 + 2 + 3 ... + n can be simplified to
-- n(n+1) / 2, but I like comprehensions
sumOneToN(0) = 0
sumOneToN(n) = n + sumOneToN(n-1)

-- Sum all elements in a list
n = 4
nsum = sumOneToN(n*n)
groupSum = nsum / n

{-
Each poisition can only be used once, and each number can only be used once.
From here, each row/column/diag can do any move unconstrained as when parrallel
combined they will be limited by the Box and Number processes.
-}

channel place:positions.nums
channel done

positions = {(i,j) | i <- {1..n},j<-{1..n}}
DiagAlpha = { place.(i,j).ns | ns <- {1..n*n}, i <- {1..n}, j <- {1..n}, i == j or i + j == n+1 }
nums = {1..n*n}

listSum(<>) = 0
listSum(list) = head(list) + listSum(tail(list))

-- Need to generate all possible orders
allGroup = {i | i <- Set({1..n*n}), card(i) == n, listSum(seq(i)) == groupSum}


-- The number process constrains the numbers being used only once.
-- Also that they're done in order, to avoid state space explosion
-- And you can't do positions you've done before
-- Do DFS for n > 3
Number({},0) = done -> Number({}, 0)
Number(posis, move) = place?pos:posis!move -> Number(diff(posis, {pos}),move-1)
NumberStart = Number(positions, n*n)

-- Row's are indexed top to bottom, if it ever matters, their only state is the
-- current total.  The current remainder limits the moves possible.

min(a, b)= if a > b then b else a
max(a, b) = if a > b then a else b

maxElem(<>, m) = m
maxElem(l, m) = maxElem(tail(l), max(head(l), m))
maxSet(s) = maxElem(tail(seq(s)),head(seq(s)))

-- {1..0} == {} so not neccesary to have cap.
-- Reduce moves freedome, always do in descending order
Group(boxes, next, {{}}) = place?pos:boxes!next -> STOP
Group(boxes, next, moves) = place?pos:boxes!next -> [] b:{maxSet(x)|x<-moves} @ Group(diff(boxes, {pos}), b, {diff(g, {b}) |g  <- moves, member(b,g)})
GroupStart(boxes) = [] b:{maxSet(x)|x<-allGroup} @ Group(boxes, b, {diff(g, {b})| g<-allGroup, member(b,g)})

Row(y) = GroupStart({(i, y) | i <- {1..n}})

Col(x) = GroupStart({(x, j) | j <- {1..n}})

DiagAsc() = GroupStart({(i, j) | i <- {1..n}, j <- {1..n}, i == j})
DiagDes() = GroupStart({(i, j) | i <- {1..n}, j <- {1..n}, i + j == n+1})


Rows = ||| i:{1..n} @ Row(i)
Cols = ||| i:{1..n} @ Col(i)
-- Diagnoals have to do the middle together if n is an odd number
Diags = if (n % 2 == 1) then
            DiagAsc() [|{|place.((n/2)+1,(n/2)+1)|}|] DiagDes()
        else
            DiagAsc() ||| DiagDes()

-- Only work toghether on diagonal moves.
Puzzle = ((Rows [|{|place|}|] Cols) [|DiagAlpha|] Diags ) [|{|place|}|] NumberStart

-- done is not hidden, so the trace refinement should should the steps required to complete puzzle

assert STOP [T= Puzzle \ {|place|}

assert STOP [T= NumberStart \ {|place|}

assert STOP [T= NumberStart [|{|place|}|] Cols \ {|place|}

assert STOP [T= Cols \ {|place|}

assert STOP [T= Col(1) \ {|place|}

assert Puzzle \Events :[divergence free]

