{- MCH assignment 2014, Part1, "Magic" Squares model
-}
-- Helper functions
-- Definition of the 1 + 2 + 3 ... + n can be simplified to
-- n(n+1) / 2, but I like comprehensions
sumOneToN(0) = 0
sumOneToN(n) = n + sumOneToN(n-1)

-- Sum all elements in a list
n = 3
nsum = sumOneToN(n*n)
groupSum = nsum / n

{-
Each poisition can only be used once, and each number can only be used once.
From here, each row/column/diag can do any move unconstrained as when parrallel
combined they will be limited by the Box and Number processes.
-}

channel place:positions.nums
channel done

positions = {(i,j) | i <- {1..n},j<-{1..n}}
DiagAlpha = { place.(i,j).ns | ns <- {1..n*n}, i <- {1..n}, j <- {1..n}, i == j or i + j == n+1 }
nums = {1..n*n}

-- A box is a position in the magic square, containing some value
-- TODO is this neccesary?
Box(pos) = place!pos?num -> STOP -- Box(pos)

-- The number process constrains the numbers being used only once.
Number({}) = done -> STOP
Number(moves) = place?pos?num:moves -> Number(diff(moves, {num}))

assert STOP [T= Number({1..n*n}) \ {|place|}

-- Row's are indexed top to bottom, if it ever matters, their only state is the
-- current total.  The current remainder limits the moves possible.

min(a, b)=
    if a > b then
        b
    else
        a

-- {1..0} == {} so not neccesary to have cap
Group(boxes, remainder)
     = place?pos:boxes?num:{1..min(remainder, n*n)} -> Group(diff(boxes, {pos}), remainder-num)
GroupStart(boxes) = Group(boxes, groupSum)

Row(y) = GroupStart({(i, y) | i <- {1..n}})

Col(x) = GroupStart({(x, j) | j <- {1..n}})

-- FIXME diags do not neccesarily have to get to 15 with this. Invert storage?
DiagAsc() = GroupStart({(i, j) | i <- {1..n}, j <- {1..n}, i == j})
DiagDes() = GroupStart({(i, j) | i <- {1..n}, j <- {1..n}, i + j == n+1})

--Puzzle1 = (Row(1) [|{|place|}|] Col(1)) [|{|place|}|] ((DiagAsc() [|{|place|}|] DiagDes) [|{|place|}|] Box(1,1))

Rows = ||| i:{1..n} @ Row(i)
Cols = ||| i:{1..n} @ Col(i)
-- Diagnoals have to do the middle together if n is an odd number
-- FIXME 2,2, is hardcoded, not every Diag has a middle.
Diags = DiagAsc() [|{|place.(2,2)|}|] DiagDes()
Boxes = [|{done}|] pos:positions @ Box(pos)
BoxesAndNumbers = Number({1..n*n}) [|{|place|}|] Boxes

-- Only work toghether on diagonal moves.
Puzzle = ((Rows [|{|place|}|] Cols) [|DiagAlpha|] Diags ) [|{|place|}|] BoxesAndNumbers

-- done is not hidden, so the trace refinement should should the steps required to complete puzzle

assert STOP [T= Puzzle \ {|place|}

assert STOP [T= BoxesAndNumbers \ {|place|}

assert STOP [T= BoxesAndNumbers [|{|place|}|] Cols \ {|place|}

