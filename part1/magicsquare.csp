{- MCH assignment 2014, Part1, "Magic" Squares model
-}
-- Helper functions
-- Definition of the 1 + 2 + 3 ... + n can be simplified to
-- n(n+1) / 2, but I like comprehensions
sumOneToN(0) = 0
sumOneToN(n) = n + sumOneToN(n-1)

-- Sum all elements in a list
n = 3
nsum = sumOneToN(n*n)
groupSum = nsum / n

{-
Each poisition can only be used once, and each number can only be used once.
From here, each row/column/diag can do any move unconstrained as when parrallel
combined they will be limited by the Box and Number processes.
-}

channel place:positions.nums
channel done

positions = {(i,j) | i <- {1..n},j<-{1..n}}
DiagAlpha = { place.(i,j).ns | ns <- {1..n*n}, i <- {1..n}, j <- {1..n}, i == j or i + j == n+1 }
nums = {1..n*n}

listSum(<>) = 0
listSum(list) = head(list) + listSum(tail(list))

-- Need to generate all possible orders
allGroup = {i | i <- Set({1..n*n}), card(i) == n, listSum(seq(i)) == groupSum}

-- A box is a position in the magic square, containing some value
-- TODO is this neccesary?
Box(pos) = place!pos?num -> STOP -- Box(pos)

-- The number process constrains the numbers being used only once.
Number({}) = done -> STOP
Number(moves) = place?pos?num:moves -> Number(diff(moves, {num}))

assert STOP [T= Number({1..n*n}) \ {|place|}

-- Row's are indexed top to bottom, if it ever matters, their only state is the
-- current total.  The current remainder limits the moves possible.

min(a, b)=
    if a > b then
        b
    else
        a

-- {1..0} == {} so not neccesary to have cap.  Know move number from card(boxes)
SubGroup(boxes, moves)
    = place?pos:boxes?num:moves -> SubGroup(diff(boxes, {pos}), diff(moves, {num}))

Group(boxes, moves)
     = [] m:moves @ SubGroup(boxes, m)

GroupStart(boxes) = Group(boxes, allGroup)

Row(y) = GroupStart({(i, y) | i <- {1..n}})

Col(x) = GroupStart({(x, j) | j <- {1..n}})

DiagAsc() = GroupStart({(i, j) | i <- {1..n}, j <- {1..n}, i == j})
DiagDes() = GroupStart({(i, j) | i <- {1..n}, j <- {1..n}, i + j == n+1})


Rows = ||| i:{1..n} @ Row(i)
Cols = ||| i:{1..n} @ Col(i)
-- Diagnoals have to do the middle together if n is an odd number
Diags = if (n % 2 == 1) then
            DiagAsc() [|{|place.(2,2)|}|] DiagDes()
        else
            DiagAsc() ||| DiagDes()
Boxes = [|{done}|] pos:positions @ Box(pos)
BoxesAndNumbers = Number({1..n*n}) [|{|place|}|] Boxes

-- Only work toghether on diagonal moves.
Puzzle = ((Rows [|{|place|}|] Cols) [|DiagAlpha|] Diags ) [|{|place|}|] BoxesAndNumbers

-- done is not hidden, so the trace refinement should should the steps required to complete puzzle

assert STOP [T= Puzzle \ {|place|}

assert STOP [T= BoxesAndNumbers \ {|place|}

assert STOP [T= BoxesAndNumbers [|{|place|}|] Cols \ {|place|}

